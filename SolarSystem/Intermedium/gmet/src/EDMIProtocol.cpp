/*
 * EDMIProtocol.cpp
 *
 *  Created on: Jun 28, 2015
 *      Author: dinglinhui
 */

#include <cassert>
#include "EDMIProtocol.h"

namespace pcols {

///////////////////////////////////////////////////////////////////////////////
// Typedefs
///////////////////////////////////////////////////////////////////////////////

typedef struct tag_CMD_EDMI {
	BYTE gtt;
	BYTE cmd;
	WORD reg;
} CMD_EDMI;

///////////////////////////////////////////////////////////////////////////////
// static helper data
///////////////////////////////////////////////////////////////////////////////

static const CMD_EDMI l_commands[] = {
/////////////////////////////////////////////////////////////
// 瞬时量
/////////////////////////////////////////////////////////////

		{ 0x01, 'R', 0xE000 },	// A相电压
		{ 0x01, 'R', 0xE001 },	// B相电压
		{ 0x01, 'R', 0xE002 },	// C相电压

		{ 0x01, 'R', 0xE010 },	// A相电流
		{ 0x01, 'R', 0xE011 },	// B相电流
		{ 0x01, 'R', 0xE012 },	// C相电流

		{ 0x01, 'R', 0xE027 },	// Ia相位角
		{ 0x01, 'R', 0xE028 },	// Ib相位角
		{ 0x01, 'R', 0xE029 },	// Ic相位角

		{ 0x01, 'R', 0xE02A },	// Uab/Ua相位角
		{ 0x01, 'R', 0xE02B },	// Ub相位角
		{ 0x01, 'R', 0xE02C },	// Ucb/Uc相位角

		{ 0x01, 'R', 0xE030 },	// A相有功功率
		{ 0x01, 'R', 0xE031 },	// B相有功功率
		{ 0x01, 'R', 0xE032 },	// C相有功功率
		{ 0x01, 'R', 0xE033 },	// 总瞬时有功功率

		{ 0x01, 'R', 0xE040 },	// A相无功功率
		{ 0x01, 'R', 0xE041 },	// B相无功功率
		{ 0x01, 'R', 0xE042 },	// C相无功功率
		{ 0x01, 'R', 0xE043 },	// 总瞬时无功功率

		{ 0x01, 'R', 0xE026 },	// 总功率因素

		{ 0x01, 'R', 0xF010 },	// 日期
		{ 0x01, 'R', 0xF011 },	// 时间

		/////////////////////////////////////////////////////////////
		// 当前电量数据
		/////////////////////////////////////////////////////////////

		{ 0x01, 'R', 0x0060 },	// (当前)费率1反向有功总电能
		{ 0x01, 'R', 0x0061 },	// (当前)费率2反向有功总电能
		{ 0x01, 'R', 0x0062 },	// (当前)费率3反向有功总电能
		{ 0x01, 'R', 0x0063 },	// (当前)费率4反向有功总电能
		{ 0x01, 'R', 0x0069 },	// (当前)反向有功总电能

		{ 0x01, 'R', 0x0160 },	// (当前)费率1正向有功总电能
		{ 0x01, 'R', 0x0161 },	// (当前)费率2正向有功总电能
		{ 0x01, 'R', 0x0162 },	// (当前)费率3正向有功总电能
		{ 0x01, 'R', 0x0163 },	// (当前)费率4正向有功总电能
		{ 0x01, 'R', 0x0169 },	// (当前)正向有功总电能

		{ 0x01, 'R', 0x0260 },	// (当前)费率1反向无功总电能
		{ 0x01, 'R', 0x0261 },	// (当前)费率2反向无功总电能
		{ 0x01, 'R', 0x0262 },	// (当前)费率3反向无功总电能
		{ 0x01, 'R', 0x0263 },	// (当前)费率4反向无功总电能
		{ 0x01, 'R', 0x0269 },	// (当前)反向无功总电能

		{ 0x01, 'R', 0x0360 },	// (当前)费率1正向无功总电能
		{ 0x01, 'R', 0x0361 },	// (当前)费率2正向无功总电能
		{ 0x01, 'R', 0x0362 },	// (当前)费率3正向无功总电能
		{ 0x01, 'R', 0x0363 },	// (当前)费率4正向无功总电能
		{ 0x01, 'R', 0x0369 },	// (当前)正向无功总电能

		{ 0x01, 'R', 0x0660 },	// (当前)费率1一象限无功总电能
		{ 0x01, 'R', 0x0661 },	// (当前)费率2一象限无功总电能
		{ 0x01, 'R', 0x0662 },	// (当前)费率3一象限无功总电能
		{ 0x01, 'R', 0x0663 },	// (当前)费率4一象限无功总电能
		{ 0x01, 'R', 0x0669 },	// (当前)一象限无功总电能

		{ 0x01, 'R', 0x0760 },	// (当前)费率1二象限无功总电能
		{ 0x01, 'R', 0x0761 },	// (当前)费率2二象限无功总电能
		{ 0x01, 'R', 0x0762 },	// (当前)费率3二象限无功总电能
		{ 0x01, 'R', 0x0763 },	// (当前)费率4二象限无功总电能
		{ 0x01, 'R', 0x0769 },	// (当前)二象限无功总电能

		{ 0x01, 'R', 0x0860 },	// (当前)费率1三象限无功总电能
		{ 0x01, 'R', 0x0861 },	// (当前)费率2三象限无功总电能
		{ 0x01, 'R', 0x0862 },	// (当前)费率3三象限无功总电能
		{ 0x01, 'R', 0x0863 },	// (当前)费率4三象限无功总电能
		{ 0x01, 'R', 0x0869 },	// (当前)三象限无功总电能

		{ 0x01, 'R', 0x0960 },	// (当前)费率1四象限无功总电能
		{ 0x01, 'R', 0x0961 },	// (当前)费率2四象限无功总电能
		{ 0x01, 'R', 0x0962 },	// (当前)费率3四象限无功总电能
		{ 0x01, 'R', 0x0963 },	// (当前)费率4四象限无功总电能
		{ 0x01, 'R', 0x0969 },	// (当前)四象限无功总电能

		/////////////////////////////////////////////////////////////
		// 上月电量数据
		/////////////////////////////////////////////////////////////

		{ 0x02, 'R', 0x0040 },	// (上月)费率1反向有功总电能
		{ 0x02, 'R', 0x0041 },	// (上月)费率2反向有功总电能
		{ 0x02, 'R', 0x0042 },	// (上月)费率3反向有功总电能
		{ 0x02, 'R', 0x0043 },	// (上月)费率4反向有功总电能
		{ 0x02, 'R', 0x0049 },	// (上月)反向有功总电能

		{ 0x02, 'R', 0x0140 },	// (上月)费率1正向有功总电能
		{ 0x02, 'R', 0x0141 },	// (上月)费率2正向有功总电能
		{ 0x02, 'R', 0x0142 },	// (上月)费率3正向有功总电能
		{ 0x02, 'R', 0x0143 },	// (上月)费率4正向有功总电能
		{ 0x02, 'R', 0x0149 },	// (上月)正向有功总电能

		{ 0x02, 'R', 0x0640 },	// (上月)费率1一象限无功总电能
		{ 0x02, 'R', 0x0641 },	// (上月)费率2一象限无功总电能
		{ 0x02, 'R', 0x0642 },	// (上月)费率3一象限无功总电能
		{ 0x02, 'R', 0x0643 },	// (上月)费率4一象限无功总电能
		{ 0x02, 'R', 0x0649 },	// (上月)一象限无功总电能

		{ 0x02, 'R', 0x0740 },	// (上月)费率1二象限无功总电能
		{ 0x02, 'R', 0x0741 },	// (上月)费率2二象限无功总电能
		{ 0x02, 'R', 0x0742 },	// (上月)费率3二象限无功总电能
		{ 0x02, 'R', 0x0743 },	// (上月)费率4二象限无功总电能
		{ 0x02, 'R', 0x0749 },	// (上月)二象限无功总电能

		{ 0x02, 'R', 0x0840 },	// (上月)费率1三象限无功总电能
		{ 0x02, 'R', 0x0841 },	// (上月)费率2三象限无功总电能
		{ 0x02, 'R', 0x0842 },	// (上月)费率3三象限无功总电能
		{ 0x02, 'R', 0x0843 },	// (上月)费率4三象限无功总电能
		{ 0x02, 'R', 0x0849 },	// (上月)三象限无功总电能

		{ 0x02, 'R', 0x0940 },	// (上月)费率1四象限无功总电能
		{ 0x02, 'R', 0x0941 },	// (上月)费率2四象限无功总电能
		{ 0x02, 'R', 0x0942 },	// (上月)费率3四象限无功总电能
		{ 0x02, 'R', 0x0943 },	// (上月)费率4四象限无功总电能
		{ 0x02, 'R', 0x0949 },	// (上月)四象限无功总电能

		/////////////////////////////////////////////////////////////
		// 当前最大需量
		/////////////////////////////////////////////////////////////

		{ 0x01, 'R', 0x1000 },	// (当前)费率1反向有功总最大需量
		{ 0x01, 'R', 0x1001 },	// (当前)费率2反向有功总最大需量
		{ 0x01, 'R', 0x1002 },	// (当前)费率3反向有功总最大需量
		{ 0x01, 'R', 0x1003 },	// (当前)费率4反向有功总最大需量
		{ 0x01, 'R', 0x1009 },	// (当前)反向有功总最大需量

		{ 0x01, 'R', 0x1100 },	// (当前)费率1正向有功总最大需量
		{ 0x01, 'R', 0x1101 },	// (当前)费率2正向有功总最大需量
		{ 0x01, 'R', 0x1102 },	// (当前)费率3正向有功总最大需量
		{ 0x01, 'R', 0x1103 },	// (当前)费率4正向有功总最大需量
		{ 0x01, 'R', 0x1109 },	// (当前)正向有功总最大需量

		/////////////////////////////////////////////////////////////
		// 上月最大需量
		/////////////////////////////////////////////////////////////

		{ 0x02, 'R', 0x1010 },	// (上月)费率1反向有功总最大需量
		{ 0x02, 'R', 0x1011 },	// (上月)费率2反向有功总最大需量
		{ 0x02, 'R', 0x1012 },	// (上月)费率3反向有功总最大需量
		{ 0x02, 'R', 0x1013 },	// (上月)费率4反向有功总最大需量
		{ 0x02, 'R', 0x1019 },	// (上月)反向有功总最大需量

		{ 0x02, 'R', 0x1110 },	// (上月)费率1正向有功总最大需量
		{ 0x02, 'R', 0x1111 },	// (上月)费率2正向有功总最大需量
		{ 0x02, 'R', 0x1112 },	// (上月)费率3正向有功总最大需量
		{ 0x02, 'R', 0x1113 },	// (上月)费率4正向有功总最大需量
		{ 0x02, 'R', 0x1119 },	// (上月)正向有功总最大需量

		/////////////////////////////////////////////////////////////
		// 当前最大需量发生时间
		/////////////////////////////////////////////////////////////

		{ 0x01, 'R', 0x8000 },	// (当前)费率1反向有功最大需量发生时间
		{ 0x01, 'R', 0x8001 },	// (当前)费率2反向有功最大需量发生时间
		{ 0x01, 'R', 0x8002 },	// (当前)费率3反向有功最大需量发生时间
		{ 0x01, 'R', 0x8003 },	// (当前)费率4反向有功最大需量发生时间
		{ 0x01, 'R', 0x8009 },	// (当前)反向有功总电能

		{ 0x01, 'R', 0x8100 },	// (当前)费率1正向有功最大需量发生时间
		{ 0x01, 'R', 0x8101 },	// (当前)费率2正向有功最大需量发生时间
		{ 0x01, 'R', 0x8102 },	// (当前)费率3正向有功最大需量发生时间
		{ 0x01, 'R', 0x8103 },	// (当前)费率4正向有功最大需量发生时间
		{ 0x01, 'R', 0x8109 },	// (当前)正向有功总最大需量发生时间

		/////////////////////////////////////////////////////////////
		// 上月最大需量发生时间
		/////////////////////////////////////////////////////////////

		{ 0x02, 'R', 0x8010 },	// (上月)费率1反向有功最大需量发生时间
		{ 0x02, 'R', 0x8011 },	// (上月)费率2反向有功最大需量发生时间
		{ 0x02, 'R', 0x8012 },	// (上月)费率3反向有功最大需量发生时间
		{ 0x02, 'R', 0x8013 },	// (上月)费率4反向有功最大需量发生时间
		{ 0x02, 'R', 0x8019 },	// (上月)反向有功总最大需量发生时间

		{ 0x02, 'R', 0x8110 },	// (上月)费率1正向有功最大需量发生时间
		{ 0x02, 'R', 0x8111 },	// (上月)费率2正向有功最大需量发生时间
		{ 0x02, 'R', 0x8112 },	// (上月)费率3正向有功最大需量发生时间
		{ 0x02, 'R', 0x8113 },	// (上月)费率4正向有功最大需量发生时间
		{ 0x02, 'R', 0x8119 },	// (上月)正向有功总最大需量发生时间

		/////////////////////////////////////////////////////////////
		// 退出
		/////////////////////////////////////////////////////////////
		{ 0x01, 'X', 0 }, { 0x02, 'X', 0 }, };

///////////////////////////////////////////////////////////////////////////////
// CEDMIProtocol
///////////////////////////////////////////////////////////////////////////////

CEDMIProtocol::CEDMIProtocol(BYTE nMPT, PF_EDMI_SAVE pSave) :
		CGMProtocol(nMPT),
		m_pfSave(pSave) {
}

CEDMIProtocol::~CEDMIProtocol(void) {
}

int CEDMIProtocol::GetCommands(void *parms, Command *&pCMDs, PointType) {
	pCMDs = new Command;
	if (pCMDs != nullptr) {
		pCMDs->m_nAck = 1;
		((CMD_EDMI*) pCMDs->m_body)->gtt = (BYTE) (*(int *) parms);
		((CMD_EDMI*) pCMDs->m_body)->cmd = 0;
		((CMD_EDMI*) pCMDs->m_body)->reg = 0;
		pCMDs->m_pNext = nullptr;
		pCMDs->m_pAck = nullptr;
		return 1;
	}
	return 0;
}

int CEDMIProtocol::GetCommandsEx(BYTE gtt, Command *&pCMDs) {
	Command **ppCMD = &pCMDs;
	int nNums = 0;
	int nSize = sizeof(l_commands) / sizeof(CMD_EDMI);
	for (int i = 0; i < nSize; ++i) {
		if ((gtt == l_commands[i].gtt) && (l_commands[i].cmd != 'A')) {
			*ppCMD = new Command;
			if (*ppCMD != nullptr) {
				(*ppCMD)->m_nAck = 1;
				((CMD_EDMI*) (*ppCMD)->m_body)->gtt = l_commands[i].gtt;
				((CMD_EDMI*) (*ppCMD)->m_body)->cmd = l_commands[i].cmd;
				((CMD_EDMI*) (*ppCMD)->m_body)->reg = l_commands[i].reg;
				(*ppCMD)->m_pNext = nullptr;
				(*ppCMD)->m_pAck = nullptr;
				ppCMD = &(*ppCMD)->m_pNext;
				nNums++;
			}
		}
	}
	return nNums;
}

int CEDMIProtocol::HandleTx(CGMPoint *pMP, Command *pCMD, BYTE *lpBuf, int nBufSize) {
	assert(pMP != nullptr);
	assert(pCMD != nullptr);

	int nRet = 0;
	int nSize = 0;

	BYTE buff[32] = { 0 };
	MKX_FRAME frm;
	frm.data = buff;
	memcpy(frm.hdr.dest, pMP->m_host, 6);

	CMD_EDMI *ptr = (CMD_EDMI*) pCMD->m_body;

	switch (ptr->cmd) {
	case 0:
		nRet = MKX_Access(&frm);
		break;

	case 'L':
		nRet = MKX_Logon(&frm, pMP->m_user, pMP->m_password);
		break;

	case 'R':
		nRet = MKX_Read(&frm, ptr->reg);
		break;

	case 'X':
		nRet = MKX_Logoff(&frm);
		break;

	default:
		nRet = -1;
		break;
	}

	if (nRet == 0) {
		nSize = MKX_MakeFrame(&frm, lpBuf, nBufSize);
	}
	return nSize;
}

int CEDMIProtocol::HandleRx(CGMPoint *pMP, Command *pCMD, BYTE *lpBuf, int nBufSize) {
	assert(pMP != nullptr);
	assert(pCMD != nullptr);
	assert(lpBuf != nullptr);

	MKX_FRAME frm;
	BYTE buff[128] = { 0 };
	frm.data = buff;

	CMD_EDMI *ptr = (CMD_EDMI*) pCMD->m_body;

	int nRet = MKX_GetFrame(&frm, lpBuf, nBufSize);
	if (nRet == 0) {
		nRet = -1;

		switch (ptr->cmd) {
		// 进入命令行模式
		case 0:
			if (frm.hdr.code == MKX_ACK) {
				Command *pRes = new Command;
				if (pRes != nullptr) {
					pRes->m_nAck = 1;
					((CMD_EDMI*) pRes->m_body)->gtt = ptr->gtt;
					((CMD_EDMI*) pRes->m_body)->cmd = 'L';
					((CMD_EDMI*) pRes->m_body)->reg = 0;
					pRes->m_pNext = nullptr;
					pRes->m_pAck = nullptr;
					pCMD->m_pAck = pRes;
					nRet = 0;
					break;
				}
			}
			break;

			// 登录
		case 'L':
			if (frm.hdr.code == MKX_ACK) {
				Command *pRes = nullptr;
				int nNum = GetCommandsEx(ptr->gtt, pRes);
				if (nNum > 0) {
					pCMD->m_pAck = pRes;
					nRet = 0;
				}
			}
			break;

			// 退出
		case 'X':
			if (frm.hdr.code == MKX_ACK) {
				nRet = 0;
			}
			break;

			// 读数据
		case 'R':
			if (frm.hdr.code == 'R') {
				if (frm.hdr.length < 64) {
					WORD di = 0;
					memcpy(&di, frm.data, sizeof(WORD));
					int value[64 / sizeof(int)] = { 0 };
					memcpy(value, &frm.data[sizeof(WORD)], frm.hdr.length - sizeof(WORD));
					m_pfSave(pMP, (void*) ptr->gtt, di, (void*) value);
				}
			}
			nRet = 0;
			break;
		}
	}
	return nRet;
}

} /* namespace pcols */
